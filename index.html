<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Frontend data</title>

		<meta name="description" content="Frontend camp 2015, Understanding Promises">
		<meta name="author" content="Nolan Lawson">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/simple.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<link rel="stylesheet" href="index.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>
		
		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">
			<div class="slides">
				<section>
          <h2>Understanding promises</h2>
          <h4>Nolan Lawson</h4>
          <div class="footer">
            <span class="text-muted">
              Speaker notes are in the console
            </span>
          </div>
          <aside class="notes">
            Hi everybody.
          </aside>
        </section>

        <section>

          <img src="img/problem.png" alt="We have a problem with promises article"/>

          <aside class="notes">
            So the reason I'm standing in front of you right now
            is because I wrote this article on promises.

            I wrote this article, which has been described rather accurately
            as a "tutorial disguised as a rant." That's pretty much what it is.

          </aside>
        </section>

        <section>
          <img src="img/pouchdb-api.png" alt="PouchDB API screenshot"/>
          <aside class="notes">

            I wrote it because I work on a very promise-heavy open-source library
            called PouchDB, and I was tired of perusing the questions on
            Stack Overflow and seeing the same errors again and again.

            Or rather, I was tired of having to explain everything again and again -
            how not to use promises as if they were callbacks, how to
            use for-loops within a promise, etc. So I did write it all
            as a kind of rant, in one Saturday afternoon, and I've never seen any
            article I've written blow up as much as this one. I got 500 new
            Twitter followers in a few weeks, which for me means they doubled,
            because I am not a superstar.

            So apparently there was a big need for this kind of rant/tutorial.

            I think the reason for that is that a lot of us are using promises
            because we feel like we have to; it's good for us. Or rather,
            promises kind of rushed onto the scene a few years ago, and we've
            been struggling to keep up, especially with libraries that
            kinda-implement promises or kinda-don't, or use this weird
            promise from another dimension called "deferreds." Or they're migrating
            from non-promises to promises, as Angular has, and it's kinda not
            clear which is which.

            But promises are being trumpted as the exciting new technology,
            and a lot of us feel compelled to go along with it. So we dip our
            toes in here and there, maybe try a taste of promsies in one
            library, while in another library we're still clinging to our
            familiar callback patterns like a life raft. All the while, we're
            not really taking a step back and trying to figure out what
            the point of all this stuff is, anyway.

            That's what this talk is about. So if you've already read my article,
            I can assure you you won't be bored, because there will be plenty of
            new material. and if you haven't read it, don't worry, because I won't
            leave you behind.
          </aside>
        </section>

        <section>
          <img class="no-border" src="img/no-puns.png" alt="no promise puns"/>
          <aside class="notes">

            Oh and one more thing. I am sick to death of these "I promise to call
            you back"-style puns, so you won't find them in this talk. OK, they
            were funny the first time, I get it, but please, can we just agree
            to stop with these? If I see one more of these, I'm going to start
            a chane.org petition, I swear.




          </aside>
        </section>

        <section>
          <h3>Why do we need promises in JavaScript?</h3>
          <aside class="notes">
            Promises aren't unique to JavaScript, and they've gone by
            other names in other languages - futures, thunks, etc. But
            they're uniquely useful in JavaScript due to the design
            of the language.
          </aside>
        </section>

        <section>
          <pre><code data-trim>
public String readFile(String filename) throws IOException {
  String output = "";
  BufferedReader buff = new BufferedReader(
    new InputStreamReader(new FileInputStream(new File(filename))));
  while (buff.ready()) {
    output += buff.readLine() + "\n";
  }
  buff.close();
  return output;
}
          </code></pre>
          <aside class="notes">
            Here's an example from Java. Now, what's
            interesting here is that, from the point of view of a beginner,
            there's no difference between this part of the code, "readLine()"
            and the rest of tit. But if we were to promise this function
            without our larger code, it'd probably be the readLine() that ends
            up costing the most, especially if we're working with large files.
            In short, bottlenecks tend to pile up exactly where we're doing these sorts
            of InputStream operations.

            You might asay that the IOException communicates that, but there are
            plenty of parts of the Java core libraries that throw errors like
            this, e.g. the JSON parser or SAX parser, which doesn't require any I/O.
          </aside>
        </section>

        <section>
          <pre><code data-trim>
import requests;

response = request.get('http://oursite.com/ourapi/');
json = response.json()
print json

          </code></pre>
          <aside class="notes">
            Here's an example from Python. Again, we really have no reason,
            as a beginner, to suspect that that second line will probably
            be much slower than any other line in our code. But of course an
            experienced developer will know that this HTTP server could take
            a very long time to respond, or not at all, so you better keep
            an eye on that part of the code.
          </aside>
        </section>

        <section>
          <pre><code data-trim>
var xhr = new XMLHttpRequest();
xhr.onload = function () { /* handle error */ };
xhr.error = function () { /* handle success */ };
xhr.open('GET', 'http://oursite.com/ourapi/');
          </code></pre>
          <aside class="notes">
            The guy who designed JavaScript, Brendan Eich, was pretty smart.
            and one of the interesting design decisions he made for
            JavaScript was to make it single-threaded, with callbacks for
            AJAX requests. In JavaScript, this allows the single thread to
            continue working, e.g. responding to user clicks or updating
            the DOM, even when an HTTP request is ongoing.

          </aside>
        </section>

        <section>
          <pre><code data-trim>
var fs = require('fs');
fs.readFile('/tmp/myfile.txt', 'utf-8', function (err, text) {
  if (err) {
    // handle error
  } else {
    // handle success
  }
});
          </code></pre>
          <aside class="notes">

            This style continued with Node.js, and in fact it's the primary
            reason Ryan Dahl chose JavaScript for his single-threaded server
            framework. Here's a filesystem operation, which doesn't exist
            in the browser, but which looks very similar to the ajax
            request we saw earlier.

            So, in JavaScript, it's extremely obvious when a piece of code
            goes to the disk or to the network, because there's this
            awkward callback style you have to deal with. And it turns out
            this is kind of nice, because as this infographic shows,
            the network is much slower than the disk, which is much slower
            than anything done in-memory. My takeaway is: disk is about a
            zillion times slower than in-memory, and the network is about
            a zillion times slower than that.

            So JavaScript makes it really obvious when you're going to disk
            or the network, which can be nice for identifying bottlenecks
            or for ensuring that your single-threaded language doesn't spend
            any time waiting on I/O. And when webapps were using some light
            jQuery for a few ajax requests, which were almost never chained
            together, this was almost tolerable. But when Node.js came along,
            it just ended up being a huge hassle to write everything in this
            pyramid style when you just want to do a few I/O operations.

            The Node community tried to solve this early on by standardizing
            everything related to callbacks. But really this was just a convention,
            and nobody was forced to adhere to it, and people frequently
            messed it up. A common source of errors was accidentally calling
            a callback twice, or zero times, or with both an error and
            a result, etc. Lots of libraries sprang up proposing to solve
            this problem, such as async and q. But in fact they had very different
            and incompatible approaches, and jQuery and Angular had their own,
            so out of all this mess a few very smart people managed to hammer
            together a spec, and got almost everybody to agree on a small core
            of best practices, which they called the Promises A+ spec. Today
            this is enshrined in ES6, and it's in every major browser and soon
            Node.js, so it's here for the long haul. The only major holdouts
            are, sadly, jQuery and async. But you can convert their style to
            the official style, or just not use them.

            Okay, so everybody started using promises, and everything was great,
            right? Well, not exactly. First off, there is some confusion
            about which libraries and browsers actually use promises, and then
            second off there is confusion about how to use promises correctly.
            Let's talk about the libraries and browsers first.
          </aside>
        </section>

        <section>
          <aside class="notes">

          </aside>
        </section>

        <section>
          <aside class="notes">

          </aside>
        </section>

        <section>
          <aside class="notes">

          </aside>
        </section>

        <section>
          <aside class="notes">

          </aside>
        </section>

        <section>
          <aside class="notes">

          </aside>
        </section>

        <section>
          <aside class="notes">

          </aside>
        </section>

        <section>
          <aside class="notes">

          </aside>
        </section>

        <section>
          <aside class="notes">

          </aside>
        </section>

        <section>
          <aside class="notes">

          </aside>
        </section>

      </div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>
		<script src="js/jquery-1.9.1.js"></script>
		<script src="js/highcharts.js"></script>
		<script src="js/highcharts-exporting.js"></script>
    <script src="js/ua.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,
        fragments: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'linear', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});

      Reveal.addEventListener( 'slidechanged', function( event ) {
        // event.previousSlide, event.currentSlide, event.indexh, event.indexv
        var notes = event.currentSlide.querySelector(".notes");
        if(notes) {
          console.info(notes.innerHTML.replace(/\n\s+/g,'\n'));
        }
      } );

      Reveal.addEventListener('fragmentshown', function (e) {
        // show the animations
        $(e.target).find('li span').each(function (i, el) {
          $(el).addClass('anim' + (i + 1));
        });
      });

      Reveal.addEventListener('fragmenthidden', function (e) {
        // hide the animations
        $(e.target).find('li span').each(function (i, el) {
          $(el).removeClass('anim' + (i + 1));
        });
      });

      // log the first slide's notes as well
      console.info(document.querySelector(
        'section.present aside.notes').innerHTML.replace(/\n\s+/g,'\n'));

      if (!UA.isChrome() && !UA.isFirefox() && !UA.isAndroid() && !UA.isOpera()) {
        window.alert(
          'Heads up! This presentation looks best in ' +
          'Firefox/Chrome due to WEBM video and flexbox. Sorry!');
      }
    </script>

	</body>
</html>
